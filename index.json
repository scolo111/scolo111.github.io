[{"categories":null,"content":"验证方法学 动态验证与形式验证 test plan 设计 ","date":"2020-09-28","objectID":"/basic_knowledge/:0:1","tags":null,"title":"Basic_knowledge","uri":"/basic_knowledge/"},{"categories":null,"content":"OOP 继承 多态 一个对象的方法可能呈现出多种形态，既可以是对象自身的，也可以是对象父类的。 virtual申明（OOP的多态特性） virtual 申明的方法称为虚方法。虚方法可以被重载。虚方法的签名在被继承时需要保持一致。子类的指针以父类的类型传递时，其表现依然是子类的行为。 重载的好处在于调用父类方法的代码不需要重写指针就可以执行子类的方法。 virtual interface TODO virtual sequencer 如果测试框架中含有多个sequencer，就需要一个`virtual sequencer`来统一管理。它与普通的sequencer的不同在于，它不与任何driver连接。`virtual sequencer`包含一个指向其他agent内sequencer的句柄。sequencer通过这个句柄来发不同的包。 ","date":"2020-09-28","objectID":"/basic_knowledge/:0:2","tags":null,"title":"Basic_knowledge","uri":"/basic_knowledge/"},{"categories":null,"content":"验证语言SV 数据结构 * 动态数组队列有什么区别，队列能通过索引取值吗 约束 约束的写法 开关约束 ","date":"2020-09-28","objectID":"/basic_knowledge/:0:3","tags":null,"title":"Basic_knowledge","uri":"/basic_knowledge/"},{"categories":null,"content":"UVM验证方法学 UVM的理解 UVM提供了一个基本的通用的验证框架。这个框架可以被灵活的扩展修改。并且部分代码可以相对独立的拆分出来，提高了重用性。对于覆盖率驱动的验证来说，更多的工作来于设计多种多样的激励，uvm将driver 和 sequence分离就可很好的减少改动。 ","date":"2020-09-28","objectID":"/basic_knowledge/:0:4","tags":null,"title":"Basic_knowledge","uri":"/basic_knowledge/"},{"categories":null,"content":"工厂机制 工厂机制有什么好处？ 可以改变一个对象的类型为其派生的类，而不用修改多少源代码。 通过工厂机制进行覆盖的要求 TODO 域的自动化有什么好处？ TODO 请描述UVM的各个组件？ 如何启动test？ vcs 命令行加UVM_TEST_NAME, ","date":"2020-09-28","objectID":"/basic_knowledge/:0:5","tags":null,"title":"Basic_knowledge","uri":"/basic_knowledge/"},{"categories":null,"content":"Config DB * config db有什么参数？ `cntxt`, `inst_name`, `field_name`，`value`。前三者构成目标的索引路径。 * 如果环境中有两个config db set，哪个有效？ 在hierarchy中更高级的会有效，同级中最后一次申明的会有效。 ","date":"2020-09-28","objectID":"/basic_knowledge/:0:6","tags":null,"title":"Basic_knowledge","uri":"/basic_knowledge/"},{"categories":null,"content":"脚本 用过的：回归管理脚本，寄存器模型生成脚本，agent，environment模板生成脚本。 还没用到的：顶层生成脚本。 回归管理脚本设计思路 ","date":"2020-09-28","objectID":"/basic_knowledge/:0:7","tags":null,"title":"Basic_knowledge","uri":"/basic_knowledge/"},{"categories":null,"content":"验证经验 解决问题的方法？ 复杂问题可以拆解为尽可能低耦合的子问题，然后逐个拆解。 做小的代码实验来还原问题。 请描述一下你所验过的模块的功能。 UART `TODO` FLASH_CTRL `TODO` ","date":"2020-09-28","objectID":"/basic_knowledge/:0:8","tags":null,"title":"Basic_knowledge","uri":"/basic_knowledge/"},{"categories":null,"content":"覆盖率 你们项目中都会考虑哪些coverage? 一、代码覆盖率，line，toggle, FSM, conditon, branch. 其中toggle因为比较难达到100%，而且达到了也没有很有用。所以可以只关注模块IO的toggle。 二、功能覆盖率。 这部分用还不多，只知道功能覆盖率是为了弥补代码覆盖率的不足。例如MCU中的地址，代码覆盖率并不能告诉我们总共有哪些值被验证到了，而功能覆盖率就可以。 你是如何定义功能覆盖率的？考虑了哪些点? `TODO` ","date":"2020-09-28","objectID":"/basic_knowledge/:0:9","tags":null,"title":"Basic_knowledge","uri":"/basic_knowledge/"},{"categories":null,"content":"断言 断言分几种？简述下断言的用法。 按照是否依赖时钟，断言可以分为两种类型。立即断言和并发断言。 断言的目的是为了早期发现一些问题，例如满的FIFO不能被写入，2个信号必须互斥，2个信号之间都特定的时序。 ","date":"2020-09-28","objectID":"/basic_knowledge/:0:10","tags":null,"title":"Basic_knowledge","uri":"/basic_knowledge/"},{"categories":null,"content":"项目介绍 项目内容介绍 遇到的问题 解决的方法和最后的思考 ","date":"2020-09-28","objectID":"/basic_knowledge/:0:11","tags":null,"title":"Basic_knowledge","uri":"/basic_knowledge/"},{"categories":["opentitan"],"content":"背景 在ic设计验证中，每个memory都会采用一个verilog模型来模拟memory IP。而每个memory的真实存储单元都会由一个多维数组 来模拟。例如一个flash存储单元内的data区就可能叫: reg [DataWidth-1:0] main_mem [Depth-1:0] 在IC验证时，如果涉及到memory IP的验证或者SOC的系统级验证时，经常需要对多个memory进行初始化，随机，加载数据，读出数据等操作。 此时如果能有个一个统一的接口绑定用于处理这些操作。那么验证代码将会变得更加精简，高效。 ","date":"2020-09-23","objectID":"/mem_bkdr_if/:0:1","tags":["ic","uvm"],"title":"memory bkdr vif","uri":"/mem_bkdr_if/"},{"categories":["opentitan"],"content":"源码分析 Opentitan 中的文档介绍如下README 实现原理：将main_mem的hierarchy 路径拆分成2部分。MEM_HIER, MEM_SLICE。 MEM_HIER为每个memory的根路径，在tb中定义。 `define FLASH_DATA_MEM_HIER(i) \\ dut.u_flash_eflash.gen_flash_banks[``i``].i_core.i_flash.gen_generic.u_impl_generic.u_mem MEM_SLICE在mem_bkdr_if内定义的相对。接口的的方法都可以通过MEM_SLICE这个句柄来操作。 `define MEM_ARR_PATH_SLICE gen_generic.u_impl_generic.mem 通过bind将 MEM_HIER 与 MEM_SLICE 拼接。 bind `FLASH_DATA_MEM_HIER(i) mem_bkdr_if mem_bkdr_if(); 将接口传入uvm_environment flash_part_e part; part = flash_ctrl_pkg::FlashPartData; uvm_config_db#(mem_bkdr_vif)::set(null, \"*.env\", $sformatf(\"mem_bkdr_vifs[%0s][%0d]\", part.name(), i), `FLASH_DATA_MEM_HIER(i).mem_bkdr_if); 通过接口操作memory cfg.mem_bkdr_vifs[part][i].set_mem(); ","date":"2020-09-23","objectID":"/mem_bkdr_if/:0:2","tags":["ic","uvm"],"title":"memory bkdr vif","uri":"/mem_bkdr_if/"},{"categories":["opentitan"],"content":"注意事项 Opentitan中的实现方法需要每个memory内的MEM_SLICE同名。对于不同名的memory，目前还没有找到解决方案。 MEM_SLICE 定义时需要至少2级hierarchy才能被vcs识别为路径。 ","date":"2020-09-23","objectID":"/mem_bkdr_if/:0:3","tags":["ic","uvm"],"title":"memory bkdr vif","uri":"/mem_bkdr_if/"},{"categories":null,"content":"This Blog is for my personal database for everthing. Projects study: ","date":"2018-12-20","objectID":"/about/about/:0:0","tags":null,"title":"About me","uri":"/about/about/"}]